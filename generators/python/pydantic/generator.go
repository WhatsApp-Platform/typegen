package pydantic

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/WhatsApp-Platform/typegen/generators"
	"github.com/WhatsApp-Platform/typegen/parser/ast"
)

// Generator generates Python code with Pydantic models from TypeGen AST
type Generator struct {
	importMap     map[string]bool   // Track required imports
	config        map[string]string // Configuration options
	cyclicTypes   map[string]bool   // Track types that are part of cycles
	definedTypes  map[string]bool   // Track which types have been defined already
}

// NewGenerator creates a new Python code generator
func NewGenerator() *Generator {
	return &Generator{
		importMap:    make(map[string]bool),
		config:       make(map[string]string),
		cyclicTypes:  make(map[string]bool),
		definedTypes: make(map[string]bool),
	}
}

// SetConfig implements generators.Generator interface
func (g *Generator) SetConfig(config map[string]string) {
	g.config = config
}

// Generate implements generators.Generator interface for module generation
func (g *Generator) Generate(ctx context.Context, module *ast.Module, dest generators.FS) error {
	return g.generateModuleRecursive(ctx, module, dest, "")
}

// generateModuleRecursive recursively generates Python code for a module and its submodules
func (g *Generator) generateModuleRecursive(ctx context.Context, module *ast.Module, dest generators.FS, basePath string) error {
	// Collect all types defined in this module for __init__.py re-exports
	var allTypes []string
	var moduleImports []string

	// Generate Python file for each .tg file in this module
	for filename, program := range module.Files {
		// Convert filename from .tg to .py
		pythonFilename := strings.TrimSuffix(filename, ".tg") + ".py"
		pythonPath := dest.Join(basePath, pythonFilename)

		// Generate code for this file
		code, err := g.generateProgram(program)
		if err != nil {
			return fmt.Errorf("failed to generate code for %s: %w", filename, err)
		}

		// Write the file
		if err := dest.WriteFile(pythonPath, []byte(code), 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", pythonPath, err)
		}

		// Collect types from this file for re-export
		moduleBaseName := strings.TrimSuffix(filename, ".tg")
		typesFromFile := g.getTypesFromProgram(program)

		if len(typesFromFile) > 0 {
			moduleImports = append(moduleImports, fmt.Sprintf("from .%s import %s", moduleBaseName, strings.Join(typesFromFile, ", ")))
			allTypes = append(allTypes, typesFromFile...)
		}
	}

	// Recursively process submodules
	for subModuleName, subModule := range module.SubModules {
		subModulePath := dest.Join(basePath, subModuleName)
		if err := g.generateModuleRecursive(ctx, subModule, dest, subModulePath); err != nil {
			return fmt.Errorf("failed to generate submodule %s: %w", subModuleName, err)
		}
	}

	// Create __init__.py with re-exports (deduplicate types)
	uniqueTypes := g.deduplicateTypes(allTypes)
	initContent := g.generateInitPy(moduleImports, uniqueTypes)
	initPath := dest.Join(basePath, "__init__.py")
	if err := dest.WriteFile(initPath, []byte(initContent), 0644); err != nil {
		return fmt.Errorf("failed to create %s: %w", initPath, err)
	}

	return nil
}

// generateProgram converts a TypeGen program to Python code
func (g *Generator) generateProgram(program *ast.ProgramNode) (string, error) {
	g.importMap = make(map[string]bool)    // Reset imports for each generation
	g.cyclicTypes = make(map[string]bool)  // Reset cyclic types tracking
	g.definedTypes = make(map[string]bool) // Reset defined types tracking

	var parts []string

	// Add generated file header
	parts = append(parts, "# Code generated by TypeGen. DO NOT EDIT.")
	parts = append(parts, "")

	// Process imports first to determine dependencies
	for _, imp := range program.Imports {
		importStmt := g.generateImport(imp.Path)
		parts = append(parts, importStmt)
	}
	if len(program.Imports) > 0 {
		parts = append(parts, "")
	}

	// Sort declarations topologically, handling circular references
	sortedDeclarations, cyclicTypes, err := g.topologicalSortWithCycles(program.Declarations)
	if err != nil {
		return "", fmt.Errorf("failed to sort declarations: %w", err)
	}
	
	// Store cyclic types for forward reference generation
	for _, typeName := range cyclicTypes {
		g.cyclicTypes[typeName] = true
	}

	// Generate declarations in sorted order
	for _, decl := range sortedDeclarations {
		code, err := g.generateDeclaration(decl)
		if err != nil {
			return "", err
		}
		parts = append(parts, code)
		parts = append(parts, "")
		
		// Track that this type has been defined
		declName := g.getDeclName(decl)
		if declName != "" {
			g.definedTypes[declName] = true
		}
	}

	// Add model_rebuild() calls for cyclic types and variant classes that use forward references
	allTypesNeedingRebuild := g.collectTypesNeedingRebuild(cyclicTypes, sortedDeclarations)
	if len(allTypesNeedingRebuild) > 0 {
		parts = append(parts, "# Rebuild models to resolve forward references")
		for _, typeName := range allTypesNeedingRebuild {
			parts = append(parts, fmt.Sprintf("%s.model_rebuild()", typeName))
		}
		parts = append(parts, "")
	}

	// Build final code with imports at top
	result := g.buildImports()
	if result != "" {
		result += "\n\n"
	}

	result += strings.Join(parts, "\n")
	return result, nil
}

// generateImport converts a TypeGen import path to Python import statement
func (g *Generator) generateImport(importPath string) string {
	// Check if module-name config is provided
	moduleName, hasModuleName := g.config["module-name"]

	parts := strings.Split(importPath, ".")

	if hasModuleName && moduleName != "" {
		// With module-name config, generate: "from mypackage.some.other import module"
		if len(parts) == 1 {
			// Single module: "from mypackage import module"
			return fmt.Sprintf("from %s import %s", moduleName, importPath)
		} else {
			// Nested module: "from mypackage.some.other import module"
			module := parts[len(parts)-1]
			packagePath := strings.Join(parts[:len(parts)-1], ".")
			return fmt.Sprintf("from %s.%s import %s", moduleName, packagePath, module)
		}
	} else {
		// Without module-name config, use original behavior
		if len(parts) == 1 {
			// Simple import: "import module"
			return fmt.Sprintf("import %s", importPath)
		} else {
			// Complex import: "from some.other import module"
			module := parts[len(parts)-1]
			packagePath := strings.Join(parts[:len(parts)-1], ".")
			return fmt.Sprintf("from %s import %s", packagePath, module)
		}
	}
}

// buildImports generates the import statements
func (g *Generator) buildImports() string {
	if len(g.importMap) == 0 {
		return ""
	}

	var imports []string
	for imp := range g.importMap {
		imports = append(imports, imp)
	}
	sort.Strings(imports)

	return strings.Join(imports, "\n")
}

// generateDeclaration generates Python code for a declaration
func (g *Generator) generateDeclaration(decl ast.Declaration) (string, error) {
	switch d := decl.(type) {
	case *ast.StructNode:
		return g.generateStruct(d)
	case *ast.EnumNode:
		return g.generateEnum(d)
	case *ast.TypeAliasNode:
		return g.generateTypeAlias(d)
	case *ast.ConstantNode:
		return g.generateConstant(d)
	default:
		return "", fmt.Errorf("unknown declaration type: %T", decl)
	}
}

// generateStruct generates a Pydantic BaseModel for a struct
func (g *Generator) generateStruct(s *ast.StructNode) (string, error) {
	g.importMap["from pydantic import BaseModel"] = true

	var parts []string
	parts = append(parts, fmt.Sprintf("class %s(BaseModel):", s.Name))

	if len(s.Fields) == 0 {
		parts = append(parts, "    pass")
		return strings.Join(parts, "\n"), nil
	}

	for _, field := range s.Fields {
		fieldCode, err := g.generateField(field)
		if err != nil {
			return "", err
		}
		parts = append(parts, "    "+fieldCode)
	}

	return strings.Join(parts, "\n"), nil
}

// generateField generates a field definition for Pydantic
func (g *Generator) generateField(field *ast.FieldNode) (string, error) {
	pythonName := g.toPythonFieldName(field.Name)
	pythonType, err := g.generateType(field.Type, field.Optional)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%s: %s", pythonName, pythonType), nil
}

// generateEnum generates a Python Enum
func (g *Generator) generateEnum(e *ast.EnumNode) (string, error) {
	g.importMap["from enum import Enum"] = true

	// Check if any variants have payloads - if so, use a different approach
	hasPayloads := false
	for _, variant := range e.Variants {
		if variant.Payload != nil {
			hasPayloads = true
			break
		}
	}

	if hasPayloads {
		return g.generateTaggedUnion(e)
	}

	// Simple enum without payloads - use custom class with JSON serialization
	g.importMap["from typing import Any"] = true
	g.importMap["from pydantic_core import CoreSchema, core_schema"] = true
	g.importMap["from pydantic import GetCoreSchemaHandler, GetJsonSchemaHandler"] = true
	g.importMap["from pydantic.json_schema import JsonSchemaValue"] = true

	var parts []string
	parts = append(parts, fmt.Sprintf("class %s(Enum):", e.Name))

	if len(e.Variants) == 0 {
		parts = append(parts, "    pass")
		return strings.Join(parts, "\n"), nil
	}

	// Generate enum values as strings
	for _, variant := range e.Variants {
		parts = append(parts, fmt.Sprintf("    %s = \"%s\"", strings.ToUpper(variant.Name), variant.Name))
	}

	// Add custom Pydantic schema for JSON serialization
	parts = append(parts, "")
	parts = append(parts, "    @classmethod")
	parts = append(parts, "    def __get_pydantic_core_schema__(cls, _source_type: Any, _handler: GetCoreSchemaHandler) -> CoreSchema:")
	parts = append(parts, "        return core_schema.no_info_after_validator_function(")
	parts = append(parts, "            cls._validate_from_json,")
	parts = append(parts, "            core_schema.union_schema([")
	parts = append(parts, "                core_schema.is_instance_schema(cls),")
	parts = append(parts, "                core_schema.dict_schema(),")
	parts = append(parts, "                core_schema.str_schema(),")
	parts = append(parts, "            ]),")
	parts = append(parts, "            serialization=core_schema.plain_serializer_function_ser_schema(")
	parts = append(parts, "                cls._serialize_to_json,")
	parts = append(parts, "                return_schema=core_schema.dict_schema(),")
	parts = append(parts, "            ),")
	parts = append(parts, "        )")
	parts = append(parts, "")
	parts = append(parts, "    @classmethod")
	parts = append(parts, fmt.Sprintf("    def _validate_from_json(cls, v: Any) -> '%s':", e.Name))
	parts = append(parts, "        if isinstance(v, cls):")
	parts = append(parts, "            return v")
	parts = append(parts, "        if isinstance(v, dict):")
	parts = append(parts, "            type_str = v.get('type')")
	parts = append(parts, "            if type_str is None:")
	parts = append(parts, "                raise ValueError(\"Missing 'type' field\")")

	// Add validation cases for each variant
	for _, variant := range e.Variants {
		parts = append(parts, fmt.Sprintf("            if type_str == \"%s\":", variant.Name))
		parts = append(parts, fmt.Sprintf("                return cls.%s", strings.ToUpper(variant.Name)))
	}

	parts = append(parts, "            raise ValueError(f\"Unknown type: {type_str}\")")
	parts = append(parts, "        if isinstance(v, str):")
	parts = append(parts, "            return cls(v)")
	parts = append(parts, "        raise ValueError(f\"Cannot convert {type(v)} to {cls.__name__}\")")
	parts = append(parts, "")
	parts = append(parts, "    def _serialize_to_json(self) -> dict:")
	parts = append(parts, "        return {\"type\": self.value}")

	return strings.Join(parts, "\n"), nil
}

// generateTaggedUnion generates a tagged union for enums with payloads
func (g *Generator) generateTaggedUnion(e *ast.EnumNode) (string, error) {
	g.importMap["from typing import Union"] = true
	g.importMap["from typing import Literal"] = true
	g.importMap["from pydantic import BaseModel"] = true

	var parts []string
	var variantTypes []string

	// Generate a class for each variant
	for _, variant := range e.Variants {
		className := fmt.Sprintf("%s_%s", e.Name, g.toPascalCase(variant.Name))
		parts = append(parts, fmt.Sprintf("class %s(BaseModel):", className))
		parts = append(parts, fmt.Sprintf("    type: Literal['%s'] = '%s'", variant.Name, variant.Name))

		if variant.Payload != nil {
			pythonType, err := g.generateType(variant.Payload, false)
			if err != nil {
				return "", err
			}
			parts = append(parts, fmt.Sprintf("    payload: %s", pythonType))
		}

		parts = append(parts, "")
		variantTypes = append(variantTypes, className)
	}

	// Generate the union type
	parts = append(parts, fmt.Sprintf("%s = Union[%s]", e.Name, strings.Join(variantTypes, ", ")))

	return strings.Join(parts, "\n"), nil
}

// generateTypeAlias generates a type alias
func (g *Generator) generateTypeAlias(t *ast.TypeAliasNode) (string, error) {
	pythonType, err := g.generateType(t.Type, false)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%s = %s", t.Name, pythonType), nil
}

// generateConstant generates a Python constant declaration with Final type hint
func (g *Generator) generateConstant(c *ast.ConstantNode) (string, error) {
	g.importMap["from typing import Final"] = true

	switch value := c.Value.(type) {
	case *ast.IntConstant:
		return fmt.Sprintf("%s: Final[int] = %d", c.Name, value.Value), nil
	case *ast.StringConstant:
		return fmt.Sprintf("%s: Final[str] = %q", c.Name, value.Value), nil
	default:
		return "", fmt.Errorf("unsupported constant value type: %T", value)
	}
}

// generateType converts a TypeGen type to Python type annotation
func (g *Generator) generateType(t ast.Type, optional bool) (string, error) {
	var baseType string

	switch typ := t.(type) {
	case *ast.PrimitiveType:
		baseType = g.mapPrimitiveType(typ.Name)
	case *ast.NamedType:
		// Check if this type needs forward reference
		if g.needsForwardReference(typ.Name) {
			baseType = fmt.Sprintf("'%s'", typ.Name)
		} else {
			baseType = typ.Name
		}
	case *ast.ArrayType:
		g.importMap["from typing import List"] = true
		elementType, err := g.generateType(typ.ElementType, false)
		if err != nil {
			return "", err
		}
		baseType = fmt.Sprintf("List[%s]", elementType)
	case *ast.MapType:
		g.importMap["from typing import Dict"] = true
		keyType, err := g.generateType(typ.KeyType, false)
		if err != nil {
			return "", err
		}
		valueType, err := g.generateType(typ.ValueType, false)
		if err != nil {
			return "", err
		}
		baseType = fmt.Sprintf("Dict[%s, %s]", keyType, valueType)
	case *ast.OptionalType:
		return g.generateType(typ.ElementType, true)
	default:
		return "", fmt.Errorf("unknown type: %T", t)
	}

	if optional {
		g.importMap["from typing import Optional"] = true
		return fmt.Sprintf("Optional[%s]", baseType), nil
	}

	return baseType, nil
}

// mapPrimitiveType maps TypeGen primitive types to Python types
func (g *Generator) mapPrimitiveType(typeName string) string {
	switch typeName {
	case "bool":
		return "bool"
	case "string":
		return "str"
	case "int8", "int16", "int32", "int64":
		return "int"
	case "nat8", "nat16", "nat32", "nat64":
		return "int" // Python doesn't distinguish signed/unsigned
	case "float32", "float64":
		return "float"
	case "json":
		g.importMap["from typing import Any"] = true
		return "Any"
	case "time":
		g.importMap["from datetime import datetime"] = true
		return "datetime"
	case "date":
		g.importMap["from datetime import date"] = true
		return "date"
	case "duration":
		g.importMap["from datetime import timedelta"] = true
		return "timedelta"
	default:
		return typeName // Fallback to original name
	}
}

// toPythonFieldName converts TypeGen field names (snake_case) to Python (already snake_case)
func (g *Generator) toPythonFieldName(name string) string {
	return name // TypeGen already uses snake_case for fields
}

// needsForwardReference determines if a type reference needs to be quoted for forward reference
func (g *Generator) needsForwardReference(typeName string) bool {
	// If it's a qualified name (contains dot), don't forward reference
	if strings.Contains(typeName, ".") {
		return false
	}
	
	// If this type is marked as cyclic and hasn't been defined yet, use forward reference
	return g.cyclicTypes[typeName] && !g.definedTypes[typeName]
}

// collectTypesNeedingRebuild collects all types that need model_rebuild() calls
func (g *Generator) collectTypesNeedingRebuild(cyclicTypes []string, declarations []ast.Declaration) []string {
	rebuildsNeeded := make(map[string]bool)
	
	// Add all cyclic types
	for _, typeName := range cyclicTypes {
		rebuildsNeeded[typeName] = true
	}
	
	// Check enum variant classes for forward references
	for _, decl := range declarations {
		if enumNode, ok := decl.(*ast.EnumNode); ok {
			hasPayloads := false
			for _, variant := range enumNode.Variants {
				if variant.Payload != nil {
					hasPayloads = true
					break
				}
			}
			
			if hasPayloads {
				// Check each variant for forward references
				for _, variant := range enumNode.Variants {
					if variant.Payload != nil {
						if g.typeUsesForwardReference(variant.Payload) {
							className := fmt.Sprintf("%s_%s", enumNode.Name, g.toPascalCase(variant.Name))
							rebuildsNeeded[className] = true
						}
					}
				}
			}
		}
	}
	
	// Convert to sorted slice
	var result []string
	for typeName := range rebuildsNeeded {
		result = append(result, typeName)
	}
	sort.Strings(result)
	
	return result
}

// typeUsesForwardReference checks if a type (recursively) uses forward references
func (g *Generator) typeUsesForwardReference(t ast.Type) bool {
	switch typ := t.(type) {
	case *ast.NamedType:
		// Check if this type is cyclic (regardless of whether it's been defined yet)
		return g.cyclicTypes[typ.Name]
	case *ast.ArrayType:
		return g.typeUsesForwardReference(typ.ElementType)
	case *ast.MapType:
		return g.typeUsesForwardReference(typ.KeyType) || g.typeUsesForwardReference(typ.ValueType)
	case *ast.OptionalType:
		return g.typeUsesForwardReference(typ.ElementType)
	default:
		return false
	}
}

// toPascalCase converts snake_case to PascalCase for Python class names
func (g *Generator) toPascalCase(name string) string {
	parts := strings.Split(name, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]))
			if len(part) > 1 {
				result.WriteString(part[1:])
			}
		}
	}
	return result.String()
}

// topologicalSortWithCycles sorts declarations and handles circular references
func (g *Generator) topologicalSortWithCycles(declarations []ast.Declaration) ([]ast.Declaration, []string, error) {
	// Create map from declaration name to declaration
	declMap := make(map[string]ast.Declaration)
	for _, decl := range declarations {
		declMap[g.getDeclName(decl)] = decl
	}

	// Build dependency graph
	dependencies := make(map[string][]string)
	for _, decl := range declarations {
		name := g.getDeclName(decl)
		deps := g.analyzeDependencies(decl, declMap)
		dependencies[name] = deps
	}

	// Perform topological sort using Kahn's algorithm with cycle handling
	return g.kahnSortWithCycles(declarations, dependencies)
}

// getDeclName returns the name of a declaration
func (g *Generator) getDeclName(decl ast.Declaration) string {
	switch d := decl.(type) {
	case *ast.StructNode:
		return d.Name
	case *ast.EnumNode:
		return d.Name
	case *ast.TypeAliasNode:
		return d.Name
	case *ast.ConstantNode:
		return d.Name
	default:
		return ""
	}
}

// analyzeDependencies finds all user-defined types that a declaration depends on
func (g *Generator) analyzeDependencies(decl ast.Declaration, declMap map[string]ast.Declaration) []string {
	var deps []string
	seen := make(map[string]bool)

	switch d := decl.(type) {
	case *ast.StructNode:
		for _, field := range d.Fields {
			g.collectTypeDependencies(field.Type, declMap, seen, &deps)
		}
	case *ast.EnumNode:
		for _, variant := range d.Variants {
			if variant.Payload != nil {
				g.collectTypeDependencies(variant.Payload, declMap, seen, &deps)
			}
		}
	case *ast.TypeAliasNode:
		g.collectTypeDependencies(d.Type, declMap, seen, &deps)
	case *ast.ConstantNode:
		// Constants have no type dependencies
	}

	return deps
}

// collectTypeDependencies recursively collects all type dependencies
func (g *Generator) collectTypeDependencies(t ast.Type, declMap map[string]ast.Declaration, seen map[string]bool, deps *[]string) {
	switch typ := t.(type) {
	case *ast.NamedType:
		// Only include dependencies on types defined in this file
		if !strings.Contains(typ.Name, ".") { // Not a qualified name
			if _, exists := declMap[typ.Name]; exists && !seen[typ.Name] {
				seen[typ.Name] = true
				*deps = append(*deps, typ.Name)
			}
		}
	case *ast.ArrayType:
		g.collectTypeDependencies(typ.ElementType, declMap, seen, deps)
	case *ast.MapType:
		g.collectTypeDependencies(typ.KeyType, declMap, seen, deps)
		g.collectTypeDependencies(typ.ValueType, declMap, seen, deps)
	case *ast.OptionalType:
		g.collectTypeDependencies(typ.ElementType, declMap, seen, deps)
	}
}

// kahnSortWithCycles performs topological sort with cycle handling
func (g *Generator) kahnSortWithCycles(declarations []ast.Declaration, dependencies map[string][]string) ([]ast.Declaration, []string, error) {
	// Calculate in-degrees and build reverse dependency graph
	inDegree := make(map[string]int)
	declMap := make(map[string]ast.Declaration)
	dependents := make(map[string][]string) // reverse dependency map: dependency -> list of dependents

	for _, decl := range declarations {
		name := g.getDeclName(decl)
		inDegree[name] = 0
		declMap[name] = decl
		dependents[name] = []string{}
	}

	// Build in-degrees and reverse dependencies
	for declName, deps := range dependencies {
		inDegree[declName] = len(deps)
		for _, dep := range deps {
			dependents[dep] = append(dependents[dep], declName)
		}
	}

	// Initialize queue with nodes that have no incoming edges (no dependencies)
	var queue []string
	for name, degree := range inDegree {
		if degree == 0 {
			queue = append(queue, name)
		}
	}

	var result []ast.Declaration
	visited := 0

	for len(queue) > 0 {
		// Remove node from queue
		current := queue[0]
		queue = queue[1:]

		result = append(result, declMap[current])
		visited++

		// For each node that depends on current
		for _, dependent := range dependents[current] {
			inDegree[dependent]--
			if inDegree[dependent] == 0 {
				queue = append(queue, dependent)
			}
		}
	}

	// Handle cycles: if there are remaining nodes, they are part of cycles
	var cyclicTypes []string
	if visited < len(declarations) {
		// Find all nodes that are part of cycles (have non-zero in-degree)
		for name, degree := range inDegree {
			if degree > 0 {
				cyclicTypes = append(cyclicTypes, name)
				result = append(result, declMap[name])
			}
		}
		
		// Sort cyclic types for consistent output
		sort.Strings(cyclicTypes)
	}

	return result, cyclicTypes, nil
}

// getTypesFromProgram extracts all type names defined in a program
func (g *Generator) getTypesFromProgram(program *ast.ProgramNode) []string {
	var types []string

	for _, decl := range program.Declarations {
		switch d := decl.(type) {
		case *ast.StructNode:
			types = append(types, d.Name)
		case *ast.EnumNode:
			types = append(types, d.Name)
			// For tagged unions, also include variant classes
			hasPayloads := false
			for _, variant := range d.Variants {
				if variant.Payload != nil {
					hasPayloads = true
					break
				}
			}
			if hasPayloads {
				for _, variant := range d.Variants {
					className := fmt.Sprintf("%s_%s", d.Name, g.toPascalCase(variant.Name))
					types = append(types, className)
				}
			}
		case *ast.TypeAliasNode:
			types = append(types, d.Name)
		case *ast.ConstantNode:
			types = append(types, d.Name)
		}
	}

	return types
}

// deduplicateTypes removes duplicate type names from a slice
func (g *Generator) deduplicateTypes(types []string) []string {
	seen := make(map[string]bool)
	var unique []string

	for _, t := range types {
		if !seen[t] {
			seen[t] = true
			unique = append(unique, t)
		}
	}

	return unique
}

// generateInitPy creates the content for __init__.py with re-exports
func (g *Generator) generateInitPy(moduleImports []string, allTypes []string) string {
	var parts []string

	// Add imports from modules
	if len(moduleImports) > 0 {
		for _, imp := range moduleImports {
			parts = append(parts, imp)
		}
		parts = append(parts, "")
	}

	// Add __all__ list for explicit exports
	if len(allTypes) > 0 {
		parts = append(parts, "__all__ = [")
		sort.Strings(allTypes) // Sort for consistent output
		for i, typeName := range allTypes {
			if i == len(allTypes)-1 {
				parts = append(parts, fmt.Sprintf("    %q", typeName))
			} else {
				parts = append(parts, fmt.Sprintf("    %q,", typeName))
			}
		}
		parts = append(parts, "]")
	} else {
		// If no types, just have an empty __all__
		parts = append(parts, "__all__ = []")
	}

	return strings.Join(parts, "\n")
}

func init() {
	// Register the Python+Pydantic generator globally
	generators.Register("python+pydantic", func() generators.Generator {
		return NewGenerator()
	})
}
