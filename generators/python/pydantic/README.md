# TypeGen Python+Pydantic Generator

The Python+Pydantic generator creates Python code with [Pydantic](https://pydantic.dev) models from TypeGen schema definitions. It generates type-safe, modern Python code with full validation support.

## Features

- **Pydantic BaseModel classes** from TypeGen structs  
- **Python Enums and Tagged Unions** from TypeGen enums
- **Type aliases** for simple type definitions
- **Full type annotations** with proper imports
- **Optional field support** using `Optional[T]`
- **Collections support** (`List[T]`, `Dict[K,V]`)
- **Recursive module generation** with proper package structure
- **Cross-module type references** 

## Generated Code Examples

### Structs → Pydantic Models

TypeGen input:
```typegen
struct User {
  id: int64
  email: ?string
  tags: []string
  metadata: [string]string
}
```

Generated Python:
```python
from typing import List, Dict, Optional
from pydantic import BaseModel

class User(BaseModel):
    id: int
    email: Optional[str]
    tags: List[str]
    metadata: Dict[str, str]
```

### Enums → Python Enums or Tagged Unions

#### Simple Enums

TypeGen input:
```typegen
enum Status {
  active
  inactive
  pending
}
```

Generated Python:
```python
from enum import Enum

class Status(Enum):
    ACTIVE = 1
    INACTIVE = 2
    PENDING = 3
```

#### Enums with Payloads → Tagged Unions

TypeGen input:
```typegen
enum Result {
  success
  error: string
  partial: []string
}
```

Generated Python:
```python
from typing import List, Union, Literal
from pydantic import BaseModel

class ResultSuccess(BaseModel):
    tag: Literal['success'] = 'success'

class ResultError(BaseModel):
    tag: Literal['error'] = 'error'
    value: str

class ResultPartial(BaseModel):
    tag: Literal['partial'] = 'partial'
    value: List[str]

Result = Union[ResultSuccess, ResultError, ResultPartial]
```

### Type Aliases

TypeGen input:
```typegen
type UserID = int64
type Timestamp = int64
```

Generated Python:
```python
UserID = int
Timestamp = int
```

## Type Mapping

| TypeGen Type | Python Type | Import Required |
|--------------|-------------|-----------------|
| `bool` | `bool` | - |
| `string` | `str` | - |
| `int8`, `int16`, `int32`, `int64` | `int` | - |
| `nat8`, `nat16`, `nat32`, `nat64` | `int` | - |
| `float32`, `float64` | `float` | - |
| `json` | `Any` | `from typing import Any` |
| `time` | `datetime` | `from datetime import datetime` |
| `date` | `date` | `from datetime import date` |
| `duration` | `timedelta` | `from datetime import timedelta` |
| `?Type` | `Optional[Type]` | `from typing import Optional` |
| `[]Type` | `List[Type]` | `from typing import List` |
| `[K]V` | `Dict[K, V]` | `from typing import Dict` |

## Module Structure Generation

The Python generator creates proper Python package structure with `__init__.py` files:

### Input Structure
```
schemas/
├── user.tg
├── auth/
│   ├── token.tg
│   └── permissions.tg
└── api/
    └── v1/
        └── endpoints.tg
```

### Generated Structure
```
output/
├── __init__.py              # Generated by TypeGen
├── user.py                  # User-related models
├── auth/
│   ├── __init__.py          # Generated by TypeGen
│   ├── token.py             # Token models
│   └── permissions.py       # Permission models
└── api/
    ├── __init__.py          # Generated by TypeGen
    └── v1/
        ├── __init__.py      # Generated by TypeGen
        └── endpoints.py     # API endpoint models
```

## Usage

### CLI Usage

Generate Python code for an entire module:

```bash
# Basic usage
typegen generate -generator python+pydantic -o ./generated/python ./schemas

# With custom import root
typegen generate -generator python+pydantic -c module-name=mycompany.services -o ./generated/python ./schemas
```

### Programmatic Usage

```go
import (
    "context"
    "github.com/WhatsApp-Platform/typegen/generators"
    "github.com/WhatsApp-Platform/typegen/parser"
    
    // Import to register the generator
    _ "github.com/WhatsApp-Platform/typegen/generators/python/pydantic"
)

// Parse module
module, err := parser.ParseModuleToAST("./schemas")
if err != nil {
    log.Fatal(err)
}

// Get Python+Pydantic generator
generator, err := generators.Get("python+pydantic")
if err != nil {
    log.Fatal(err)
}

// Generate code
fs := generators.NewOSFS("./output")
ctx := context.Background()
if err := generator.Generate(ctx, module, fs); err != nil {
    log.Fatal(err)
}
```

## Advanced Features

### Cross-Module References

The generator handles qualified type names from imports:

TypeGen input:
```typegen
import auth

struct User {
  id: int64
  credentials: auth.Credentials
}
```

Generated Python:
```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    credentials: auth_Credentials  # Converted for Python naming
```

### Import Configuration (Optional)

The Python generator supports an optional `module-name` configuration to customize import roots for better package organization.

#### Without module-name (default behavior)
```bash
typegen generate -generator python+pydantic -o ./output ./schemas
```

TypeGen imports are converted directly:
```typegen
import auth
import some.other.module.service
```

Generates:
```python
import auth
from some.other.module import service
```

#### With module-name configuration
```bash
typegen generate -generator python+pydantic -c module-name=mycompany.api -o ./output ./schemas  
```

TypeGen imports are prefixed with the module name:
```typegen
import auth
import some.other.module.service
```

Generates:
```python
from mycompany.api import auth
from mycompany.api.some.other.module import service
```

#### Import Conversion Examples

| TypeGen Import | Without module-name | With module-name=mycompany.services |
|----------------|-------------------|-----------------------------------|
| `import auth` | `import auth` | `from mycompany.services import auth` |
| `import payment.stripe` | `from payment import stripe` | `from mycompany.services.payment import stripe` |
| `import api.v1.users` | `from api.v1 import users` | `from mycompany.services.api.v1 import users` |

This configuration is particularly useful when integrating generated code into existing Python packages.

### Naming Conventions

The generator follows Python naming conventions:

- **Field names**: Keep TypeGen `snake_case` (already Python-compliant)
- **Class names**: Keep TypeGen `PascalCase` (already Python-compliant)  
- **Enum variants**: Convert to `UPPER_CASE` for simple enums
- **Tagged union classes**: Convert `snake_case` to `PascalCase` (e.g., `project_admin` → `ProjectAdmin`)
- **Qualified names**: Convert dots to underscores (e.g., `auth.Token` → `auth_Token`)

## Error Handling

The generator provides detailed error messages:

```
Generation error: failed to generate code for user.tg: unknown type: CustomType
Generation error: failed to write auth/token.py: permission denied
Generation error: failed to generate submodule auth: failed to parse auth/invalid.tg: syntax error
```

## Testing

### Test with InMemoryFS

```go
func TestPythonGenerator(t *testing.T) {
    // Create test module
    input := `struct User { id: int64; name: string }`
    program, err := parser.Parse(strings.NewReader(input), "user.tg")
    require.NoError(t, err)
    
    module := ast.NewModule("test", map[string]*ast.ProgramNode{
        "user.tg": program,
    })
    
    // Generate code
    fs := generators.NewInMemoryFS()
    generator := python.NewGenerator()
    ctx := context.Background()
    
    err = generator.Generate(ctx, module, fs)
    require.NoError(t, err)
    
    // Verify results
    assert.True(t, fs.FileExists("__init__.py"))
    assert.True(t, fs.FileExists("user.py"))
    
    content, exists := fs.GetFileString("user.py")
    require.True(t, exists)
    assert.Contains(t, content, "class User(BaseModel):")
    assert.Contains(t, content, "id: int")
    assert.Contains(t, content, "name: str")
}
```

## Implementation Details

### Generator Structure

```go
type Generator struct {
    importMap map[string]bool // Track required imports per file
}
```

The generator maintains state for:
- **Import tracking**: Automatically adds required imports (`typing`, `pydantic`, etc.)
- **Per-file generation**: Resets state for each `.tg` file
- **Recursive processing**: Handles submodules with proper path management

### Key Methods

- `Generate(ctx, module, fs)`: Main entry point, handles recursive module structure
- `generateModuleRecursive()`: Processes module and submodules recursively  
- `generateProgram()`: Converts single TypeGen program to Python code
- `generateDeclaration()`: Handles structs, enums, and type aliases
- `generateType()`: Maps TypeGen types to Python types with imports

### Import Management

The generator automatically manages imports:

```python
# Only includes imports that are actually used
from enum import Enum
from typing import List, Dict, Optional, Union, Literal  
from pydantic import BaseModel, Field
from datetime import datetime, date, timedelta
```

## Extensibility

The Python generator can be extended by:

1. **Custom type mappings**: Add new primitive type conversions
2. **Import customization**: Modify import generation logic  
3. **Naming strategies**: Customize field/class name conversion
4. **Output formatting**: Adjust code style and formatting

Example extension:
```go
func (g *Generator) mapCustomType(typeName string) string {
    switch typeName {
    case "uuid":
        g.importMap["from uuid import UUID"] = true
        return "UUID"
    case "decimal":
        g.importMap["from decimal import Decimal"] = true  
        return "Decimal"
    default:
        return g.mapPrimitiveType(typeName)
    }
}
```

## Requirements

Generated Python code requires:
- **Python 3.7+** (for proper type annotation support)
- **Pydantic 2.x** (for BaseModel and validation)

Install dependencies:
```bash
pip install "pydantic>=2.0"
```

## Future Enhancements

Planned improvements:
- **Custom field validators** from TypeGen constraints
- **Serialization options** (camelCase, kebab-case output)
- **AsyncAPI/FastAPI integration** for web APIs  
- **Dataclass generation** as alternative to Pydantic
- **Type stub generation** (.pyi files) for better IDE support