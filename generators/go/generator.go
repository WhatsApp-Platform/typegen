package golang

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/WhatsApp-Platform/typegen/generators"
	"github.com/WhatsApp-Platform/typegen/parser/ast"
)

// Generator generates Go code from TypeGen AST
type Generator struct {
	packageName string
	importMap   map[string]bool   // Track required imports
	config      map[string]string // Configuration options
}

// NewGenerator creates a new Go code generator
func NewGenerator() *Generator {
	return &Generator{
		packageName: "main", // Default package name
		importMap:   make(map[string]bool),
		config:      make(map[string]string),
	}
}

// SetConfig implements generators.Generator interface
func (g *Generator) SetConfig(config map[string]string) {
	g.config = config
}

// Generate implements generators.Generator interface for module generation
func (g *Generator) Generate(ctx context.Context, module *ast.Module, dest generators.FS) error {
	return g.generateModuleRecursive(ctx, module, dest, "", module.Name)
}

// generateModuleRecursive recursively generates Go code for a module and its submodules
func (g *Generator) generateModuleRecursive(ctx context.Context, module *ast.Module, dest generators.FS, basePath, packageName string) error {
	// Generate Go file for each .tg file in this module
	for filename, program := range module.Files {
		// Convert filename from .tg to .go
		goFilename := strings.TrimSuffix(filename, ".tg") + ".go"
		goPath := dest.Join(basePath, goFilename)

		// Generate code for this file
		code, err := g.generateProgram(program, packageName)
		if err != nil {
			return fmt.Errorf("failed to generate code for %s: %w", filename, err)
		}

		// Write the file
		if err := dest.WriteFile(goPath, []byte(code), 0644); err != nil {
			return fmt.Errorf("failed to write %s: %w", goPath, err)
		}
	}

	// Recursively process submodules
	for subModuleName, subModule := range module.SubModules {
		subModulePath := dest.Join(basePath, subModuleName)
		subPackageName := subModuleName // Use submodule name as package name
		if err := g.generateModuleRecursive(ctx, subModule, dest, subModulePath, subPackageName); err != nil {
			return fmt.Errorf("failed to generate submodule %s: %w", subModuleName, err)
		}
	}

	return nil
}

// generateProgram converts a TypeGen program to Go code
func (g *Generator) generateProgram(program *ast.ProgramNode, packageName string) (string, error) {
	g.importMap = make(map[string]bool) // Reset imports for each generation
	g.packageName = packageName

	var parts []string

	// Add generated file header
	parts = append(parts, "// Code generated by TypeGen. DO NOT EDIT.")
	parts = append(parts, "")

	// Add package declaration
	parts = append(parts, fmt.Sprintf("package %s", g.packageName))
	parts = append(parts, "")

	// Process imports first to determine dependencies
	for _, imp := range program.Imports {
		// For Go, we'll need to handle qualified names in type generation
		// Store import information for later use
		if err := g.generateImport(imp.Path); err != nil {
			return "", err
		}
	}

	// Generate declarations in original order
	for _, decl := range program.Declarations {
		code, err := g.generateDeclaration(decl)
		if err != nil {
			return "", err
		}
		parts = append(parts, code)
		parts = append(parts, "")
	}

	// Build final code with header, package, and imports
	result := parts[0] + "\n" // generated header
	result += "\n" + parts[2] + "\n" // package declaration (skip empty line at parts[1])

	imports := g.buildImports()
	if imports != "" {
		result += "\n" + imports + "\n"
	}

	// Add the rest of the code (skip header, empty line, and package declaration)
	if len(parts) > 4 {
		result += "\n" + strings.Join(parts[4:], "\n")
	}

	return result, nil
}

// generateImport converts a TypeGen import path to Go import statement
func (g *Generator) generateImport(importPath string) error {
	// Convert TypeGen import path to Go import path
	// e.g., "some.other.module.auth" -> "github.com/user/project/some/other/module/auth"

	moduleName, ok := g.config["module-name"]
	if !ok || moduleName == "" {
		return fmt.Errorf("module-name configuration is required when using imports (import: %s)", importPath)
	}

	// Convert dot-separated path to slash-separated path
	goImportPath := strings.ReplaceAll(importPath, ".", "/")
	fullImportPath := fmt.Sprintf("%s/%s", moduleName, goImportPath)

	// Add to import map for later generation
	g.importMap[fmt.Sprintf("\"%s\"", fullImportPath)] = true

	return nil
}

// handleQualifiedType converts TypeGen qualified types to Go qualified types
// e.g., "auth.UserAuthentication" -> "auth.UserAuthentication"
// Also ensures the import is added for qualified types
func (g *Generator) handleQualifiedType(typeName string) string {
	if !strings.Contains(typeName, ".") {
		// Not a qualified name, return as-is
		return typeName
	}

	// Split the qualified name: "auth.UserAuthentication" -> ["auth", "UserAuthentication"]
	parts := strings.SplitN(typeName, ".", 2)
	if len(parts) != 2 {
		return typeName
	}

	packageAlias := parts[0] // e.g., "auth"
	typeName = parts[1]      // e.g., "UserAuthentication"

	// In Go, we use the same package alias as in the TypeGen import
	// The import should have been processed already in generateImport

	return fmt.Sprintf("%s.%s", packageAlias, typeName)
}

// buildImports generates the import statements
func (g *Generator) buildImports() string {
	if len(g.importMap) == 0 {
		return ""
	}

	var imports []string
	for imp := range g.importMap {
		imports = append(imports, imp)
	}
	sort.Strings(imports)

	if len(imports) == 1 {
		return fmt.Sprintf("import %s", imports[0])
	}

	result := "import (\n"
	for _, imp := range imports {
		result += fmt.Sprintf("\t%s\n", imp)
	}
	result += ")"

	return result
}

// generateDeclaration generates Go code for a declaration
func (g *Generator) generateDeclaration(decl ast.Declaration) (string, error) {
	switch d := decl.(type) {
	case *ast.StructNode:
		return g.generateStruct(d)
	case *ast.EnumNode:
		return g.generateEnum(d)
	case *ast.TypeAliasNode:
		return g.generateTypeAlias(d)
	case *ast.ConstantNode:
		return g.generateConstant(d)
	default:
		return "", fmt.Errorf("unknown declaration type: %T", decl)
	}
}

// generateStruct generates a Go struct
func (g *Generator) generateStruct(s *ast.StructNode) (string, error) {
	var parts []string
	parts = append(parts, fmt.Sprintf("type %s struct {", s.Name))

	if len(s.Fields) == 0 {
		parts = append(parts, "}")
		return strings.Join(parts, "\n"), nil
	}

	for _, field := range s.Fields {
		fieldCode, err := g.generateField(field)
		if err != nil {
			return "", err
		}
		parts = append(parts, "\t"+fieldCode)
	}

	parts = append(parts, "}")
	return strings.Join(parts, "\n"), nil
}

// generateField generates a field definition for Go struct
func (g *Generator) generateField(field *ast.FieldNode) (string, error) {
	goName := g.toGoFieldName(field.Name)
	goType, err := g.generateType(field.Type, field.Optional)
	if err != nil {
		return "", err
	}

	// Add JSON tag for field mapping
	jsonTag := fmt.Sprintf("`json:\"%s\"`", field.Name)
	return fmt.Sprintf("%s %s %s", goName, goType, jsonTag), nil
}

// generateEnum generates Go constants and a type for enum
func (g *Generator) generateEnum(e *ast.EnumNode) (string, error) {
	var parts []string

	// Check if any variants have payloads - if so, use interface approach
	hasPayloads := false
	for _, variant := range e.Variants {
		if variant.Payload != nil {
			hasPayloads = true
			break
		}
	}

	if hasPayloads {
		return g.generateTaggedUnion(e)
	}

	// Simple enum without payloads - use iota constants
	parts = append(parts, fmt.Sprintf("type %s int", e.Name))
	parts = append(parts, "")
	parts = append(parts, "const (")

	for i, variant := range e.Variants {
		constName := fmt.Sprintf("%s_%s", e.Name, g.toPascalCase(variant.Name))
		if i == 0 {
			parts = append(parts, fmt.Sprintf("\t%s %s = iota", constName, e.Name))
		} else {
			parts = append(parts, fmt.Sprintf("\t%s", constName))
		}
	}

	parts = append(parts, ")")

	// Add String() method for better debugging
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("func (e %s) String() string {", e.Name))
	parts = append(parts, "\tswitch e {")
	for _, variant := range e.Variants {
		constName := fmt.Sprintf("%s_%s", e.Name, g.toPascalCase(variant.Name))
		parts = append(parts, fmt.Sprintf("\tcase %s:", constName))
		parts = append(parts, fmt.Sprintf("\t\treturn \"%s\"", variant.Name))
	}
	parts = append(parts, "\tdefault:")
	parts = append(parts, "\t\treturn \"unknown\"")
	parts = append(parts, "\t}")
	parts = append(parts, "}")

	// Add custom JSON marshaling for simple enums to support {"type": "variant"} format
	g.importMap["\"encoding/json\""] = true
	g.importMap["\"fmt\""] = true

	// Add MarshalJSON method
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("func (e %s) MarshalJSON() ([]byte, error) {", e.Name))
	parts = append(parts, "\treturn json.Marshal(map[string]string{\"type\": e.String()})")
	parts = append(parts, "}")

	// Add UnmarshalJSON method
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("func (e *%s) UnmarshalJSON(data []byte) error {", e.Name))
	parts = append(parts, "\tvar obj map[string]string")
	parts = append(parts, "\tif err := json.Unmarshal(data, &obj); err != nil {")
	parts = append(parts, "\t\treturn err")
	parts = append(parts, "\t}")
	parts = append(parts, "")
	parts = append(parts, "\ttypeStr, ok := obj[\"type\"]")
	parts = append(parts, "\tif !ok {")
	parts = append(parts, "\t\treturn fmt.Errorf(\"missing 'type' field\")")
	parts = append(parts, "\t}")
	parts = append(parts, "")
	parts = append(parts, "\tswitch typeStr {")
	for _, variant := range e.Variants {
		constName := fmt.Sprintf("%s_%s", e.Name, g.toPascalCase(variant.Name))
		parts = append(parts, fmt.Sprintf("\tcase \"%s\":", variant.Name))
		parts = append(parts, fmt.Sprintf("\t\t*e = %s", constName))
	}
	parts = append(parts, "\tdefault:")
	parts = append(parts, "\t\treturn fmt.Errorf(\"unknown enum value: %s\", typeStr)")
	parts = append(parts, "\t}")
	parts = append(parts, "")
	parts = append(parts, "\treturn nil")
	parts = append(parts, "}")

	return strings.Join(parts, "\n"), nil
}

// generateTaggedUnion generates a tagged union for enums with payloads
func (g *Generator) generateTaggedUnion(e *ast.EnumNode) (string, error) {
	g.importMap["\"encoding/json\""] = true
	g.importMap["\"fmt\""] = true

	var parts []string

	// Generate main wrapper struct
	parts = append(parts, fmt.Sprintf("type %s struct {", e.Name))
	parts = append(parts, fmt.Sprintf("\tPayload %sPayload `json:\"-\"`", e.Name))
	parts = append(parts, "}")
	parts = append(parts, "")

	// Generate payload interface
	payloadInterfaceName := fmt.Sprintf("%sPayload", e.Name)
	parts = append(parts, fmt.Sprintf("type %s interface {", payloadInterfaceName))
	parts = append(parts, fmt.Sprintf("\t%sType() string", strings.ToLower(e.Name)))
	parts = append(parts, "}")
	parts = append(parts, "")

	// Generate variant types
	for _, variant := range e.Variants {
		variantTypeName := fmt.Sprintf("%s_%s", e.Name, g.toPascalCase(variant.Name))

		if variant.Payload != nil {
			// Variant with payload - create a type alias
			goType, err := g.generateType(variant.Payload, false)
			if err != nil {
				return "", err
			}
			parts = append(parts, fmt.Sprintf("type %s %s", variantTypeName, goType))
		} else {
			// Simple variant - create empty struct
			parts = append(parts, fmt.Sprintf("type %s struct{}", variantTypeName))
		}

		// Add interface method
		methodName := fmt.Sprintf("%sType", strings.ToLower(e.Name))
		parts = append(parts, fmt.Sprintf("func (%s) %s() string {", variantTypeName, methodName))
		parts = append(parts, fmt.Sprintf("\treturn \"%s\"", variant.Name))
		parts = append(parts, "}")
		parts = append(parts, "")
	}

	// Generate custom JSON marshaler
	parts = append(parts, fmt.Sprintf("func (e %s) MarshalJSON() ([]byte, error) {", e.Name))
	parts = append(parts, "\tswitch payload := e.Payload.(type) {")

	for _, variant := range e.Variants {
		variantTypeName := fmt.Sprintf("%s_%s", e.Name, g.toPascalCase(variant.Name))
		parts = append(parts, fmt.Sprintf("\tcase %s:", variantTypeName))

		if variant.Payload != nil {
			parts = append(parts, "\t\treturn json.Marshal(map[string]interface{}{")
			parts = append(parts, fmt.Sprintf("\t\t\t\"type\": \"%s\",", variant.Name))
			parts = append(parts, "\t\t\t\"payload\": payload,")
			parts = append(parts, "\t\t})")
		} else {
			parts = append(parts, "\t\treturn json.Marshal(map[string]interface{}{")
			parts = append(parts, fmt.Sprintf("\t\t\t\"type\": \"%s\",", variant.Name))
			parts = append(parts, "\t\t})")
		}
	}

	parts = append(parts, "\tdefault:")
	parts = append(parts, "\t\treturn nil, fmt.Errorf(\"unknown payload type: %T\", payload)")
	parts = append(parts, "\t}")
	parts = append(parts, "}")
	parts = append(parts, "")

	// Generate custom JSON unmarshaler
	parts = append(parts, fmt.Sprintf("func (e *%s) UnmarshalJSON(data []byte) error {", e.Name))
	parts = append(parts, "\tvar raw map[string]json.RawMessage")
	parts = append(parts, "\tif err := json.Unmarshal(data, &raw); err != nil {")
	parts = append(parts, "\t\treturn err")
	parts = append(parts, "\t}")
	parts = append(parts, "")
	parts = append(parts, "\ttypeBytes, exists := raw[\"type\"]")
	parts = append(parts, "\tif !exists {")
	parts = append(parts, "\t\treturn fmt.Errorf(\"missing 'type' field\")")
	parts = append(parts, "\t}")
	parts = append(parts, "")
	parts = append(parts, "\tvar typeStr string")
	parts = append(parts, "\tif err := json.Unmarshal(typeBytes, &typeStr); err != nil {")
	parts = append(parts, "\t\treturn err")
	parts = append(parts, "\t}")
	parts = append(parts, "")
	parts = append(parts, "\tswitch typeStr {")

	for _, variant := range e.Variants {
		variantTypeName := fmt.Sprintf("%s_%s", e.Name, g.toPascalCase(variant.Name))
		parts = append(parts, fmt.Sprintf("\tcase \"%s\":", variant.Name))

		if variant.Payload != nil {
			parts = append(parts, "\t\tpayloadBytes, exists := raw[\"payload\"]")
			parts = append(parts, "\t\tif !exists {")
			parts = append(parts, fmt.Sprintf("\t\t\treturn fmt.Errorf(\"missing 'payload' field for type '%s'\")", variant.Name))
			parts = append(parts, "\t\t}")
			parts = append(parts, fmt.Sprintf("\t\tvar payload %s", variantTypeName))
			parts = append(parts, "\t\tif err := json.Unmarshal(payloadBytes, &payload); err != nil {")
			parts = append(parts, "\t\t\treturn err")
			parts = append(parts, "\t\t}")
			parts = append(parts, "\t\te.Payload = payload")
		} else {
			parts = append(parts, fmt.Sprintf("\t\te.Payload = %s{}", variantTypeName))
		}
	}

	parts = append(parts, "\tdefault:")
	parts = append(parts, "\t\treturn fmt.Errorf(\"unknown type: %s\", typeStr)")
	parts = append(parts, "\t}")
	parts = append(parts, "")
	parts = append(parts, "\treturn nil")
	parts = append(parts, "}")

	return strings.Join(parts, "\n"), nil
}

// generateTypeAlias generates a type alias
func (g *Generator) generateTypeAlias(t *ast.TypeAliasNode) (string, error) {
	goType, err := g.generateType(t.Type, false)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("type %s = %s", t.Name, goType), nil
}

// generateConstant generates a Go constant declaration
func (g *Generator) generateConstant(c *ast.ConstantNode) (string, error) {
	switch value := c.Value.(type) {
	case *ast.IntConstant:
		return fmt.Sprintf("const %s = %d", c.Name, value.Value), nil
	case *ast.StringConstant:
		return fmt.Sprintf("const %s = %q", c.Name, value.Value), nil
	default:
		return "", fmt.Errorf("unsupported constant value type: %T", value)
	}
}

// generateType converts a TypeGen type to Go type
func (g *Generator) generateType(t ast.Type, optional bool) (string, error) {
	var baseType string

	switch typ := t.(type) {
	case *ast.PrimitiveType:
		baseType = g.mapPrimitiveType(typ.Name)
	case *ast.NamedType:
		baseType = g.handleQualifiedType(typ.Name)
	case *ast.ArrayType:
		elementType, err := g.generateType(typ.ElementType, false)
		if err != nil {
			return "", err
		}
		baseType = fmt.Sprintf("[]%s", elementType)
	case *ast.MapType:
		keyType, err := g.generateType(typ.KeyType, false)
		if err != nil {
			return "", err
		}
		valueType, err := g.generateType(typ.ValueType, false)
		if err != nil {
			return "", err
		}
		baseType = fmt.Sprintf("map[%s]%s", keyType, valueType)
	case *ast.OptionalType:
		return g.generateType(typ.ElementType, true)
	default:
		return "", fmt.Errorf("unknown type: %T", t)
	}

	// Handle optionality with pointers
	if optional {
		return fmt.Sprintf("*%s", baseType), nil
	}

	return baseType, nil
}

// mapPrimitiveType maps TypeGen primitive types to Go types
func (g *Generator) mapPrimitiveType(typeName string) string {
	switch typeName {
	case "bool":
		return "bool"
	case "string":
		return "string"
	case "int8":
		return "int8"
	case "int16":
		return "int16"
	case "int32":
		return "int32"
	case "int64":
		return "int64"
	case "nat8":
		return "uint8"
	case "nat16":
		return "uint16"
	case "nat32":
		return "uint32"
	case "nat64":
		return "uint64"
	case "float32":
		return "float32"
	case "float64":
		return "float64"
	case "json":
		return "interface{}"
	case "time":
		g.importMap["\"time\""] = true
		return "time.Time"
	case "date":
		g.importMap["\"time\""] = true
		return "time.Time"
	case "datetime":
		g.importMap["\"time\""] = true
		return "time.Time"
	case "timetz":
		g.importMap["\"time\""] = true
		return "time.Time"
	case "datetz":
		g.importMap["\"time\""] = true
		return "time.Time"
	case "datetimetz":
		g.importMap["\"time\""] = true
		return "time.Time"
	default:
		return typeName // Fallback to original name
	}
}

// toGoFieldName converts TypeGen field names (snake_case) to Go (PascalCase)
func (g *Generator) toGoFieldName(name string) string {
	return g.toPascalCase(name)
}

// toPascalCase converts snake_case to PascalCase for Go identifiers
func (g *Generator) toPascalCase(name string) string {
	parts := strings.Split(name, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]))
			if len(part) > 1 {
				result.WriteString(part[1:])
			}
		}
	}
	return result.String()
}


func init() {
	// Register the Go generator globally
	generators.Register("go", func() generators.Generator {
		return NewGenerator()
	})
}
